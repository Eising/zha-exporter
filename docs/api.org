#+title: ZHA API

* Introduction

[[https://developers.home-assistant.io/docs/api/websocket/][Hass websocket api]]



* Authentication
Requires a "long-lived" token from Hass

When a client connects to the server, the server sends out auth_required.

#+begin_src json
{
  "type": "auth_required",
  "ha_version": "2021.5.3"
}
#+end_src

#+begin_src json
{"type": "auth", "access_token": "MY_ACCESS_TOKEN"}
#+end_src


** Responses
Ok:
#+begin_src json
{
  "type": "auth_ok",
  "ha_version": "2021.5.3"
}


#+end_src

Failed:
#+begin_src json
{
  "type": "auth_invalid",
  "message": "Invalid password"
}
#+end_src

* URL
This seems to be a general Hass websocket endpoint

=ws://homassistant.local:8123/api/websocket=

* Queries

It seems to require an identifier integer for each request. This ident is passed to each query.

#+begin_quote
Each API message is a JSON serialized object containing a type key. After the
authentication phase messages also must contain an id, an integer that the
caller can use to correlate messages to responses.

#+end_quote

* ZHA queries

** Get devices
#+begin_src json
{"id": "correlation ID", "type": "zha/devices"}
#+end_src

*** Outer object

First level

| key    | type         | comment           |
|--------+--------------+-------------------|
| succes | bool         |                   |
| result | list of dict | Devices come here |

*** Device list
This is generated by the command =websocket_get_devices= in =homassistant/components/zha/websocket_api.py=.

#+begin_src python
    devices = [
        device.zha_device_info for device in zha_gateway_proxy.device_proxies.values()
    ]
    connection.send_result(msg[ID], devices)
# ...
device_info: dict[str, Any] = {}

        return {
            "ieee": ieee,
            "nwk": self.device.nwk,
            "manufacturer": self.device.manufacturer,
            "model": self.device.model,
            "name": self.device.name or ieee,
            "quirk_applied": self.device.quirk_applied,
            "quirk_class": self.device.quirk_class,
            "quirk_id": self.device.quirk_id,
            "manufacturer_code": self.device.manufacturer_code,
            "power_source": self.device.power_source,
            "lqi": self.device.lqi,
            "rssi": self.device.rssi,
            "last_seen": update_time,
            "available": self.device.available,
            "device_type": self.device.device_type,
            "signature": self.device.zigbee_signature,
        }

#+end_src

This device object is mostly from the library =zha=, but I suspect the more bit-oriented types are re-cast as strings.


A custom dataclass for this would be:

#+begin_src python
@dataclass
class DeviceInfo:
    """ZHA device info."""
    ieee: str  # Originally a binary type
    nwk:  str  # Originally bytes as hex
    manufacturer: str
    model: str
    name: str
    quirk_applied: bool
    quirk_class: str
    quirk_id: str | None
    manufacturer_code: int | None
    power_source: str
    lqi: int
    rssi: int
    last_seen: str
    available: bool
    device_type: str
    signature: dict[str, Any]  # annoying...

#+end_src

The signature bit comes from this property

#+begin_src python
    @cached_property
    def zigbee_signature(self) -> dict[str, Any]:
        """Get zigbee signature for this device."""
        return {
            ATTR_NODE_DESCRIPTOR: self._zigpy_device.node_desc,
            ATTR_ENDPOINTS: {
                signature[0]: signature[1]
                for signature in [
                    endpoint.zigbee_signature for endpoint in self._endpoints.values()
                ]
            },
            ATTR_MANUFACTURER: self.manufacturer,
            ATTR_MODEL: self.model,
        }

#+end_src

We could probably make this more typed...
#+begin_src python

class Endpoint:
    """Endpoint for a zha device."""

    def __init__(self, zigpy_endpoint: ZigpyEndpoint, device: Device) -> None:
        """Initialize instance."""
        assert zigpy_endpoint is not None
        assert device is not None
        self._zigpy_endpoint: ZigpyEndpoint = zigpy_endpoint
        self._device: Device = device
        self._all_cluster_handlers: dict[str, ClusterHandler] = {}
        self._claimed_cluster_handlers: dict[str, ClusterHandler] = {}
        self._client_cluster_handlers: dict[str, ClientClusterHandler] = {}
        self._unique_id: str = f"{device.unique_id}-{zigpy_endpoint.endpoint_id}"


@dataclass
class ZigbeeSignature:
    """Signature."""
    node_descriptor: str
    # This is where it becomes super hard to type...
    endpoints: dict[int, Endpoint]
    manufacturer: str
    model: str

#+end_src
